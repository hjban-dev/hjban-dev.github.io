{"componentChunkName":"component---src-blog-template-js","path":"/post/2020-01-27-level1-31-text_array","result":{"data":{"markdownRemark":{"frontmatter":{"title":"level 1-31. 문자열 내 마음대로 정렬하기 (Javascript)","tags":["Algorithm","Javascript","Exercise"]},"fields":{"slug":"2020-01-27-level1-31-text_array"},"html":"<h1>level 1. 문자열 내 마음대로 정렬하기</h1>\n<blockquote>\n<p>출처 : <a href=\"https://programmers.co.kr/learn/courses/30/lessons/12915\">https://programmers.co.kr/learn/courses/30/lessons/12915</a></p>\n</blockquote>\n<h2>문제</h2>\n<pre><code>문자열로 구성된 리스트 strings와, 정수 n이 주어졌을 때, 각 문자열의 인덱스 n번째 글자를 기준으로 오름차순 정렬하려 합니다. 예를 들어 strings가 [\"sun\", \"bed\", \"car\"]이고 n이 1이면 각 단어의 인덱스 1의 문자 \"u\", \"e\", \"a\"로 strings를 정렬합니다.\n</code></pre>\n<h3>제한사항</h3>\n<ul>\n<li>strings는 길이 1 이상, 50이하인 배열입니다.</li>\n<li>strings의 원소는 소문자 알파벳으로 이루어져 있습니다.</li>\n<li>strings의 원소는 길이 1 이상, 100이하인 문자열입니다.</li>\n<li>모든 strings의 원소의 길이는 n보다 큽니다.</li>\n<li>인덱스 1의 문자가 같은 문자열이 여럿 일 경우, 사전순으로 앞선 - 문자열이 앞쪽에 위치합니다.</li>\n</ul>\n<h4>입출력 예</h4>\n<table>\n<thead>\n<tr>\n<th>string</th>\n<th>n</th>\n<th>return</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>[\"sun\", \"bed\", \"car\"]</td>\n<td>1</td>\n<td>[\"car\", \"bed\", \"sun\"]</td>\n</tr>\n<tr>\n<td>[\"abce\", \"abcd\", \"cdx\"]</td>\n<td>2</td>\n<td>[\"abcd\", \"abce\", \"cdx\"]</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<p>입출력 예 설명</p>\n<ol>\n<li>sun, bed, car의 1번째 인덱스 값은 각각 u, e, a 입니다. 이를 기준으로 strings를 정렬하면 [\"car\", \"bed\", \"sun\"] 입니다.</li>\n<li>abce와 abcd, cdx의 2번째 인덱스 값은 c, c, x입니다. 따라서 정렬 후에는 cdx가 가장 뒤에 위치합니다. abce와 abcd는 사전순으로 정렬하면 abcd가 우선하므로, 답은 [\"abcd\", \"abce\", \"cdx\"] 입니다.</li>\n</ol>\n<h2>내가 한 풀이</h2>\n<pre><code class=\"language-javascript\">function solution(strings, n) {\n  var new_arr = strings.map(function(curr, idx){\n    return curr[n]+curr\n  })\n  var answer = new_arr.sort().map(function(a){\n    return a.slice(1, a.length)\n  })\n\n  return answer;\n}\n</code></pre>\n<p>들어오는 strings의 n번째 string을 텍스트의 맨 앞에 붙인 새 배열 new<em>arr을 만들고, 그 new</em>arr을 sort()로 정렬한 후 붙였던 첫번째 string을 slice()로 자른 배열 answer를 return 했다.</p>\n<hr>\n<h2>다른사람 풀이</h2>\n<pre><code class=\"language-javascript\">function solution(strings, n) {\n  return strings.sort((s1, s2) => s1[n] === s2[n] ? s1.localeCompare(s2) : s1[n].localeCompare(s2[n]));\n}\n</code></pre>\n<p>ㅎ..너무 간결해서 할 말이 없다.<br>\n위 코드...짧지만 분석이 은근히 안되서 보니까 localeCompare() 내장 메소드를 몰랐다. 문자열을 구분해주는 메소드이다.<br>\n짧게 쓴 풀이들이 다 localeCompare() 메소드를 사용해서 굳이 다른 풀이 안가져오고, localeCompare()만 정리하자..</p>\n<ul>\n<li>localeCompare() : 주어진 문자열의 앞 또는 뒤에 오거나 같은지 여부를 나타내는 숫자를 정렬 순서로 리턴합니다.<br>\n두 문자열을 비교하여 일치하면 0, 다르면 -1, 인자값이 원본문자열의 일부분이면 1을 리턴</li>\n</ul>\n<h2>배운점</h2>\n<p>처음엔 객체 형식의 배열을 생각했다가, 어렵게 가지 말자 생각하고 텍스트를 붙였다. 하지만 마음에 들지 않는 풀이이다...언제쯤 내 코드가 마음에 들지...원...<br>\n리팩토링을 해도 점수가 바뀌지 않으니 아쉬운 마음만 든다.<br>\n그리고 문제가 도중에 바뀌었는지 다른사람의 풀이가 실행 되지 않아서 당황스러웠다.</p>","id":"309aeb0f-2ef4-5aee-930b-b61df773e146"}},"pageContext":{"slug":"2020-01-27-level1-31-text_array"}}}