{"componentChunkName":"component---src-templates-blog-template-js","path":"/post/2020-03-13-es2015_1","result":{"data":{"markdownRemark":{"frontmatter":{"title":"Javascript ES6 문법 Scope, String, Array","tags":["Javascript","ES6"]},"fields":{"slug":"2020-03-13-es2015_1"},"html":"<blockquote>\n<p>인프런의 <a href=\"https://www.inflearn.com/course/es6-%EA%B0%95%EC%A2%8C-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/dashboard\">모던 자바스크립트(javascript) 개발을 위한 ES6 강좌</a>를 듣고 정리합니다. </p>\n</blockquote>\n<h1>자바스크립트 ES2015(ES6) 문법 정리</h1>\n<h2>Scope</h2>\n<h3>let</h3>\n<p>es2015이전의 문법에선 var라는 키워드로 정의했고, var로 선언된 변수는 스코프를 함수 단위로 결정 사용한다.</p>\n<pre><code class=\"language-javascript\">if(true){\n  var mycode = \"test\"\n}\nconsole.log(mycode) // 결과는 \"test\"\n</code></pre>\n<p>위 코드의 mycode라는 변수는 함수 안에서 선언된 것이 아니라, if문 안에 선언되어 있으므로 전역변수이다. 그래서 if문 밖에서도 mycode를 호출가능하다.</p>\n<pre><code class=\"language-javascript\">if(true){\n  let mycode = \"test\"\n}\nconsole.log(mycode) // Uncaught ReferenceError: mycode is not defined error 발생\n</code></pre>\n<p>하지만 let은 블록 단위로 스코프를 만든다. mycode는 if문 안에서만 호출 가능.</p>\n<h3>let과 closer</h3>\n<p>DOM에 ul>li 의 구조로 4개의 리스트가 있다고 가정하고, 아래 코드의 결과를 예상해보자.</p>\n<pre><code class=\"language-javascript\">const list = document.querySelectorAll('li');\nfor(var i=0; i&#x3C;list.length; i++){\n  list[i].addEventListener(\"click\", () => console.log(i+\"번째 리스트\"))\n}\n</code></pre>\n<p>리스트를 누를 때 마다 '4번째 리스트'라고 나온다. 클로저 현상으로 addEventListener의 콜백함수 안에 있는 i는 전역변수로 선언된 i를 가져오기 때문이다.</p>\n<pre><code class=\"language-javascript\">const list = document.querySelectorAll('li');\nfor(let i=0; i&#x3C;list.length; i++){\n  list[i].addEventListener(\"click\", () => console.log(i+\"번째 리스트\"))\n}\n</code></pre>\n<p>i를 지역변수화 시켜서 리스트 순서에 맞는 console을 확인할 수 있다.</p>\n<h3>const특성과 immutable array</h3>\n<p>const키워드는 불변의 값을 담을 때 사용한다. 한번 선언하면 재할당 할 수 없다.</p>\n<pre><code class=\"language-javascript\">const example = 2;\nexample = 3; // Type Error: Assignment to constant variable\n</code></pre>\n<p>하지만 아래코드처럼 push() 메소드는 사용이 가능하다.</p>\n<pre><code class=\"language-javascript\">const list = [\"apple\", \"orange\", \"banana\"];\nlist.push(\"grape\");\nconsole.log(list); // [\"apple\", \"orange\", \"banana\", \"grape\"]\n</code></pre>\n<p>const를 사용하더라도 배열과 오브젝트의 값을 변경하는 것은 가능하다.<br>\nconst가 불변은 아니라고 생각하자.</p>\n<p>조작이 불가능한 immutable array를 만들때는 concat으로 새로운 변수를 생성하자.</p>\n<pre><code class=\"language-javascript\">//immutable array 만들기 (앞, 뒤로 가기)\nconst list = [\"apple\", \"orange\", \"banana\"];\nlist2 = [].concat(list, \"grape\");\nconsole.log(list);\nconsole.log(list2);\n</code></pre>\n<p>list2는 list를 참조하여 만든 새로운 배열이다. (추가, 삭제, 변경 가능)</p>\n<h2>String</h2>\n<h3>ES2015 String 에 새로운 메서드들</h3>\n<pre><code class=\"language-javascript\">let str = \"hello world\";\nlet match1 = \"hello\";\nlet match2 = \"world\";\nconsole.log(str.startsWith(match1)); // true\nconsole.log(str.endsWith(match2)); // true\nconsole.log(str.includes(\"worlds\")); // false\n</code></pre>\n<h2>Array</h2>\n<h3>for of - 순회하기</h3>\n<p>기존의 배열 반복문 for문, forEach문</p>\n<pre><code class=\"language-javascript\">var data = [1, 2, undefined, NaN, null, ''];\n\nfor (var i = 0; i &#x3C; data.length; i++) {\n  console.log(i); // 0,1,2,3,4,5\n}\n\ndata.forEach(data => {\n  console.log(data); // 1, 2, undefined, NaN, null, ''\n});\n</code></pre>\n<p>배열의 반복문에는 for in 반복문도 있는데, for in반복문은 대상 외에 array의 상위 객체도 포함한다. 그렇기에 배열의 for in의 지양한다.</p>\n<pre><code class=\"language-javascript\">var data = [1, 2, undefined, NaN, null, ''];\n\nArray.prototype.getIndex = function() {};\n\nfor (let idx in data) {\n  console.log(data[idx]); // 1, 2, undefined, NaN, null, '', ƒ () {}\n}\n</code></pre>\n<p>그러한 실수를 줄이기 위한 방법으로 for of 반복문이 es6에서 추가 되었다.</p>\n<pre><code class=\"language-javascript\">for (let idx of data) { // 1, 2, undefined, NaN, null, ''\n  console.log(idx);\n}\n</code></pre>\n<p>for of 반복문은 문자열도 가능하다.</p>\n<pre><code class=\"language-javascript\">let str = \"hello world\"\nfor (let idx of str) {\n  console.log(idx); // h,e,l,l,o, ,w,o,r,l,d\n}\n</code></pre>\n<h3>spread operator - 배열의 복사</h3>\n<p>전개 연산자(펼침 연산자)<br>\n함수 또는 배열에 적용, 마침표 3개 (...)를 찍어 표기</p>\n<pre><code class=\"language-javascript\">let pre = ['apple', 'banana', 100];\nlet newData = [...pre];\n\nconsole.log(pre, newData); // [\"apple\", \"banana\", 100], [\"apple\", \"banana\", 100]\n</code></pre>\n<p>복사를 한 것. 두 변수가 같지는 않음 </p>\n<h3>spread operator - 몇가지 활용</h3>\n<pre><code class=\"language-javascript\">let pre = [100, 200, 'hello', null];\nlet newData = [0, 1, 2, ...pre, 300];\n\nconsole.log(pre, newData); \n// [100, 200, \"hello\", null] \n// [0, 1, 2, 100, 200, \"hello\", null, 300]\n</code></pre>\n<pre><code class=\"language-javascript\">let sum = (a,b,c)=> a + b + c;\n\nlet pre = [100, 200, 300];\n\nconsole.log(sum.apply(null, pre)); // 600 - es6이전 방법 \nconsole.log(sum(...pre)); // 600\n</code></pre>\n<h3>from 메서드로 진짜 배열 만들기</h3>\n<p>js의 모든 함수에선 매개변수를 지칭하는 arguments라는 키워드 사용 가능. arguments는 객체</p>\n<pre><code class=\"language-javascript\">function addMark() {\n  let newData = [];\n    for (let i = 0; i &#x3C; arguments.length; i++) {\n      newData.push(arguments[i] + '~');\n    }\n  console.log(newData);\n}\naddMark(1, 2, 3, 4); // [\"1~\", \"2~\", \"3~\", \"4~\"]\n</code></pre>\n<p>map을 사용할 수도 있다. 하지만 위에서 말했듯이 arguments는 객체이기 때문에 array로 변환 시켜줘야 함.<br>\nfrom을 사용하면 쉽게 변환 가능<br>\nform: 유사배열객체 또는 순회 가능한 모든 종류의 데이터 타입을 배열로 전환.</p>\n<pre><code class=\"language-javascript\">function addMark() {\n  let newArray = Array.from(arguments);\n  let newData = newArray.map(value => {\n    return value + '!';\n  });\n  console.log(newData);\n}\naddMark(1, 2, 3, 4);\n</code></pre>\n<h2>특정 문자열이 포함된 배열 만들어 반환하기 - 예제</h2>\n<pre><code class=\"language-javascript\">let print = () => {\n  let list = document.querySelectorAll('li');\n  let listArr = Array.from(list);\n  let newArr = listArr.filter(v => {\n    return v.innerText.includes('e');\n  });\n  console.log(newArr.length);\n}\nprint()\n</code></pre>","id":"0ecce666-8e6a-5076-b943-21cbe0a7843f"}},"pageContext":{"slug":"2020-03-13-es2015_1"}}}